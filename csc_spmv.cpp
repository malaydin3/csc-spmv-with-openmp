// Mert Alaydin
// October 2024
// compile with :
// g++ -fopenmp csc_spmv.cpp -o csc_spmv.out

#include <omp.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <chrono>
#include <algorithm>
#include <cmath>

using namespace std;
using std::chrono::high_resolution_clock;
using std::chrono::duration_cast;
using std::chrono::duration;
using std::chrono::milliseconds;

/*
A class for COO (coordinate) matrix type
*/
template <typename T>
class COO_Matrix {
    public:
        // number of non-zero elements in the matrix, number of rows, number of columns
        unsigned int number_of_nonzero_elements, number_of_rows, number_of_columns;
        vector<unsigned int> row_indices,column_indices;
        // non-zero values of the matrix
        vector<T> values;
        // constructor based on the text files generated by a Python script using SciPy
        COO_Matrix(const string & row_txt, const string & col_txt, const string & vals_txt, const string & dims_txt)
        {
            // Reading row indices
            std::ifstream row_file(row_txt);
            unsigned int row_val;
            while (row_file >> row_val) {
                row_indices.push_back(row_val);
            }

            // Reading column indices
            std::ifstream col_file(col_txt);
            unsigned int  col_val;
            while (col_file >> col_val) {
                column_indices.push_back(col_val);
            }

            // Reading values
            std::ifstream val_file(vals_txt);
            T value;
            while (val_file >> value) {
                values.push_back(value);
            }

            // Set the number of non-zero values
            number_of_nonzero_elements = values.size();

            // Reading matrix dimensions
            std::ifstream dim_file(dims_txt);
            if (dim_file >> number_of_rows >> number_of_columns) {
                std::cout << "Matrix dimensions: " << number_of_rows << " x " << number_of_columns << std::endl;
            }
            std::cout << "Number of non-zero elements: " << number_of_nonzero_elements << std::endl;
        }
 
        // Print out the matrix for debugging purposes 
        friend ostream& operator<<(ostream& os, const COO_Matrix& matrix) {
            os << "****\n";
            os << "Values: ";
            for(size_t i = 0; i < matrix.number_of_nonzero_elements; i++)
            {
                os << matrix.values[i] << '\t';
            }
            os << "\n";
            os << "Column indices: ";
            for(size_t i = 0; i < matrix.number_of_nonzero_elements; i++)
            {
                os << matrix.column_indices[i] << '\t';
            }
            os << "\n";
            os << "Row indices: ";
            for(size_t i = 0; i < matrix.number_of_nonzero_elements; i++)
            {
                os << matrix.row_indices[i] << '\t';
            }
            os << "\n****\n";
            return os;
        }
};
/*
A class for CSC (compressed sparse column) matrix type 
*/
template <typename T>
class CSC_Matrix {
    public:
        // number of non-zero elements in the matrix 
        unsigned int number_of_nonzero_elements, number_of_rows, number_of_columns;
        vector<unsigned int> row_indices, column_offsets;
        // non-zero values of the matrix
        vector<T> values;

        // Constructor which assumes COO format directly to answer (A)
        CSC_Matrix(const COO_Matrix<T>& coo_matrix) {
            // reserve some space for row, column and values
            number_of_nonzero_elements = coo_matrix.number_of_nonzero_elements;
            number_of_rows = coo_matrix.number_of_rows;
            number_of_columns = coo_matrix.number_of_columns;
            row_indices.resize(number_of_nonzero_elements, 0);
            column_offsets.resize(number_of_columns+1, 0);
            values.resize(number_of_nonzero_elements, 0);

            // Count the number of entries in each column
            for(unsigned int i = 0; i < number_of_nonzero_elements; i++)
            {
                column_offsets[coo_matrix.column_indices[i] + 1]++;
            }

            // sum the column offset values such that the last index is number of non-zero elements 
            for(unsigned int i = 0; i < coo_matrix.number_of_columns; i++)
            {
                column_offsets[i+1] += column_offsets[i];
            }

            // fill the row indices and values matrix 
            vector<int> visit(coo_matrix.number_of_nonzero_elements, 0);
            for(unsigned int i = 0; i < number_of_nonzero_elements; i++){
                int colIndex = coo_matrix.column_indices[i];
                int position = column_offsets[colIndex] + visit[colIndex]++;
                row_indices[position] = coo_matrix.row_indices[i];
                values[position] = coo_matrix.values[i];
            }
        }

        // Print out the matrix for debugging purposes 
        friend ostream& operator<<(ostream& os, const CSC_Matrix<T>& matrix) {
            os << "****\n";
            os << "Values: ";
            for(size_t i = 0; i < matrix.number_of_nonzero_elements; i++)
            {
                os << matrix.values[i] << '\t';
            }
            os << "\n";
            os << "Column offsets: ";
            for(size_t i = 0; i < matrix.number_of_columns+1; i++)
            {
                os << matrix.column_offsets[i] << '\t';
            }
            os << "\n";
            os << "Row Indices: ";
            for(size_t i = 0; i < matrix.number_of_nonzero_elements; i++)
            {
                os << matrix.row_indices[i] << '\t';
            }
            os << "\n****\n";
            return os;
        }

        // Function to group columns that can work in parallel
        vector<vector<int>> colorColumns() {
            vector<std::unordered_set<int>> row_color_map(number_of_rows); // Map of used colors for each row
            vector<vector<int>> color_groups; // Color groups for columns

            for (unsigned int col = 0; col < number_of_columns; ++col) {
                std::unordered_set<int> conflicting_colors; // Track colors that conflict with this column

                // Check which colors conflict by looking at rows in the current column
                for (unsigned int j = column_offsets[col]; j < column_offsets[col + 1]; ++j) {
                    int row = row_indices[j];
                    for (const int& used_color : row_color_map[row]) {
                        // Add all the colors associated with this row 
                        conflicting_colors.insert(used_color);
                    }
                }

                // Find the first available color that doesn't conflict with the column at hand
                unsigned int color_to_assign = 0;
                while (conflicting_colors.find(color_to_assign) != conflicting_colors.end()) {
                    ++color_to_assign;
                }

                // TODO: need to replace this part 
                // Resize color_groups if needed
                if (color_to_assign >= color_groups.size()) {
                    color_groups.resize(color_to_assign + 1); 
                }

                // Assign this color to the current column
                color_groups[color_to_assign].push_back(col);

                // Update row_color_map to indicate that this column's color is now used for these rows
                for (unsigned int j = column_offsets[col]; j < column_offsets[col + 1]; ++j) {
                    int row = row_indices[j];
                    row_color_map[row].insert(color_to_assign);
                }
            }

            std::cout << "Total number of groups is: " << color_groups.size() << std::endl;

            // Calculate the average number of columns per group (sequential calculation)
            float averageColumnPerGroup = 0.0f;
            for (const auto& group : color_groups) {
                averageColumnPerGroup += group.size();
            }

            std::cout << "Average column per group: " << averageColumnPerGroup / color_groups.size() << std::endl;

            return color_groups;
        }

        // a parallel function for matrix vector multiplication where we use colored columns to avoid race conditions
        vector<T> parallelVecMatMultiplicationGrouping(const vector<T>& vec){
            // conduct a vector-matrix multiplication in CSC to vector format
            // create the result vector
            vector<T> result(number_of_rows, 0);
            // Loop over color groups serially
            // Color the columns(assumed to be an offline cost!)
            vector<vector<int>> color_groups = colorColumns();
            // Create color groups (map from color to list of columns)
            auto t1 = high_resolution_clock::now();

            for (const auto& columns : color_groups){
                size_t group_size = columns.size();
                    #pragma omp parallel for 
                    for (unsigned int k = 0; k < group_size; ++k) {
                        int col = columns[k]; 
                        // Continue with multiplication
                        for (unsigned int j = column_offsets[col]; j < column_offsets[col + 1]; ++j) {
                            result[row_indices[j]] += values[j] * vec[col];
                        }
                    }
            }

            auto t2 = high_resolution_clock::now();
            duration<double, std::milli> ms_double = t2 - t1;
            std::cout << "\n";
            std::cout << "Group-parallel (iii) matrix-vec multiplication took: " << ms_double.count() << " (ms) " << std::endl;
            std::cout << "\n";
            return result;

        }


        // a parallel function for matrix vector multiplication
        vector<T> parallelVecMatMultiplicationNaive(const vector<T>& vec){
            // conduct a vector-matrix multiplication in CSC to vector format
            // create the result vector
            vector<T> result(number_of_rows, 0);
            unsigned int i, j, ind;
            T tmp;
            auto t1 = high_resolution_clock::now();
            #pragma omp parallel for private(ind, tmp, j, i)
            for(i= 0; i<number_of_columns; ++i)
            {
                for(j = column_offsets[i]; j < column_offsets[i+1]; ++j){
                    ind = row_indices[j];
                    tmp = values[j]*vec[i];
                    #pragma omp atomic
                    result[ind] += tmp;
                }
            }
            auto t2 = high_resolution_clock::now();
            duration<double, std::milli> ms_double = t2 - t1;
            std::cout << "\n";
            std::cout << "Naive-parallel (ii) matrix-vec multiplication took: " << ms_double.count() << " (ms) " << std::endl;
            std::cout << "\n";
            return result;

        }

        // a parallel function for matrix vector multiplication
        vector<T> serialVecMatMultiplication(const vector<T>& vec){
            // conduct a vector-matrix multiplication in CSC to vector format
            // create the result vector
            vector<T> result(number_of_rows, 0);
            unsigned int i, j, ind;
            T tmp;

            auto t1 = high_resolution_clock::now();
            for(i= 0; i<number_of_columns; ++i)
            {
                for(j = column_offsets[i]; j < column_offsets[i+1]; ++j){
                    ind = row_indices[j];
                    tmp = values[j]*vec[i];
                    result[ind] += tmp;
                }
            }
            auto t2 = high_resolution_clock::now();
            duration<double, std::milli> ms_double = t2 - t1;
            std::cout << "\n";
            std::cout << "Serial (i) matrix-vec multiplication took: " << ms_double.count() << " (ms) " << std::endl;
            std::cout << "\n";
            return result;

        }


};

// Some helper functions for main

// Parse the dense vector multiplication
template <typename T>
vector<T> parseDenseVector(const string & vec_txt){
    // parse the given vector file 
    vector<T>vec;
    std::ifstream vec_file(vec_txt);
    T val;
    while (vec_file >> val) {
        vec.push_back(val);
    }
    std::cout << "Vector dimensions: " << vec.size() << " x " << "1" << std::endl;
    return vec;
}

// Reduce the resultant vector 
template <typename T>
T reduceResultVector(const vector<T>& vec){
    //Check out the total sum of the vector
    T result = 0.0;
    size_t i;
    #pragma omp parallel for reduction(+ : result)
	for (i=0; i < vec.size(); i++)
	{
		result += vec[i];
	}
    return result;
}

// Compute the l2-norm of the difference vector 
template <typename T>
T computeDifferenceL2(const vector<T>& a, const vector<T>& b){
    //Check out the total sum of the vector
    T diff = 0.0;
    if (a.size() == b.size()){
        #pragma omp parallel for reduction(+ : diff)
        for (size_t i=0; i < a.size(); i++)
        {
            diff += (a[i] - b[i])*(a[i] - b[i]);
        }
    }
    else cout << "Error!: Given vectors are not the same size: " << a.size() << " " << b.size() << endl;

    return sqrt(diff);
}



int main() {

    // Create the matrix object
    // These files are already created by coo_matrix_generator.py script using SciPy in COO format
    string rowFile = "row_indices.txt";
    string colFile = "col_indices.txt";
    string valsFile = "values.txt";
    string dimsFile = "dims.txt";
    // Vector to be post-multiplied 
    string vecFile = "vec.txt";

    // Parse the vector
    vector<double> vec = parseDenseVector<double>(vecFile);

    // Create a COO matrix
    COO_Matrix<double> matrixCOO(rowFile, colFile, valsFile, dimsFile);

    // Translate to CSC format
    CSC_Matrix<double> matrix_CSC(matrixCOO);

    // Multiply with a vector 
    vector<double> result_vector_serial = matrix_CSC.serialVecMatMultiplication(vec);
    vector<double> result_vector_parallel = matrix_CSC.parallelVecMatMultiplicationNaive(vec);
    vector<double> result_vector_parallel_group = matrix_CSC.parallelVecMatMultiplicationGrouping(vec);

    // Some sanity checks below to verify parallel results
    // calculate the total sum of each implementation 
    double result_vector_parallel_sum = reduceResultVector<double>(result_vector_parallel);
    double result_vector_serial_sum = reduceResultVector<double>(result_vector_serial);
    double result_vector_parallel_group_sum = reduceResultVector<double>(result_vector_parallel_group);

    // print the total sum of the array 
    std::cout << "Serial Sum: " << result_vector_serial_sum << " Parallel Sum: " << result_vector_parallel_sum << " Group Parallel Sum: " << result_vector_parallel_group_sum << std::endl;

    // print l2-norm of the difference 
    double diff = computeDifferenceL2<double>(result_vector_serial, result_vector_parallel_group);
    std::cout << "L2-norm of the difference vector between group-parallel and serial: " << diff << std::endl;

    return 0;
}
